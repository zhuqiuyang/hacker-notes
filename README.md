# notes

Personal learning notes.

> 述而不作, 信而好古.
>
> 学而不思则罔, 思而不学则殆.

### 舍得

> 没有谁拥有技术, 要放的下, 只是为了能更好的协作.
>
> 放缓脚步, 无事最好.

* 语言, 开发环境都会变:

  * 不变的解决特定问题的, 实践经验(金科玉律)
  * 简洁设计, 鼓励正确思考, 解决正确问题. (否则, 再多层也无用)

* 不变:
  * 找到正确的问题
  * 正确的解决问题
    * 技术的运用(合理: history 证明)
    * 经验知道做事

### 理智

* 直接
  * find your real need, fill gap
* 真实, 本质, 专注
  * Find Real, No magice
  * Find essence, No more detail.
  * 少违理情想, 多内省, 少做 no use thing.
* history: know why?
  * create it or do it this way.
* 去分别, 执着
  * 去伪存真.

### 1. [How to Become A Hacker](http://www.catb.org/esr/faqs/hacker-howto.html) - Eric Steven Raymond

1.  Learn How to Program:

* recommend order: C, Lisp, Java
* serious programming: C/C++
* important to hackers: include Perl and LISP.
  > Perl is worth learning for practical reasons; it's very widely used for active web pages and system administration, so that even if you never write Perl you should learn to read it.
* Five: Python, C/C++, Java, Perl, and LISP.
  > they represent very different approaches to programming
  > Not simply by accumulating languages — you need to learn how to think about programming problems in a general way, independent of any one language.
  >
  > To be a real hacker, you need to get to the point where you can learn a new language in days by relating what's in the manual to what you already know.
  >
  > What will do it is (a) _reading code_ and (b) _writing code_.
  >
  > Hackers prefer _real_ names.

### 2. [How To Learn Hacking](http://www.catb.org/esr/faqs/hacking-howto.html) - Perter Norvig

#### 2.1 Stages of Learning How To Hack

* [The Unix and Internet Fundamentals HOWTO](http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html)

#### Hacking have some characteristics that tend to set it apart from other styles of programming.

* Hacking is done on open source...

* Hacking is lightweight and exploratory...

* Hacking places a high value on modularity and reuse...

* Hacking favors **scrap-and-rebuild** over patch-and-extend. An essential part of hacking is ruthlessly **throwing away** code that has become overcomplicated or crufty, no matter how much time you have invested in it.

### 3. [Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html)- Eric

Here's my recipe for programming success:

* Get **interested** in programming, ten years/10000 hours
* Program. Learn by doing

> the most effective learning requires a well-defined task with an **appropriate difficulty** level

* Learn at least a half dozen **programming languages:**
  * one that emphasizes class abstractions (like Java or C++),
  * one that emphasizes functional abstraction (like Lisp or ML or Haskell),
  * one that supports syntactic abstraction (like Lisp),
  * one that supports declarative specifications (like Prolog or C++ templates)
  * one that emphasizes parallelism (like Clojure or Go).
