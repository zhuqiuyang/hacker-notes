> http://www.paulgraham.com/hptoc.html

## Chap 2. Hackers and Painters

* 搞懂`theory of computation`的必要性, 与画家搞懂颜料化学成分差不多.
  * 只需要知道时空复杂度, 会写一个解析器.
* 作者认识的 hacker, no one like`static type`, 不易于涂抹.
* 当 hacker 认识到, 自己和画家是一类人, 对`用数学公式解决问题`的诱惑就会消失. (\*)
  * 大学和实验室, 强迫 hacker 称为 scientist, 企业则是工程师.
* 在大公司, hacker 仅仅是实现委员会的设计. (这也是创业公司能够成功的原因)
* hacker 怎样才能做自己喜欢的事情?: `找一份白天工作`
* 读优秀的源代码来`学习`
* 不要企盼有一个完美的设计, 再干活:
  * 预先承认规格设计是不完美的, 编程时, 根据需要, 现场修改.
  * 不要过早设计, **不要太早决定一个程序该怎么做.**
  * 合适的工具, 可以帮助避免这种危险. 最容易修改的语言就是简短的语言.
* 事实证明: `从他人角度思考问题, 真是成功的所在.`
  * 普通 hacker 和优秀 hacker 之间的区别: `会不会换位思考, 可能是最重要的单个因素`.
  * 编辑器和 compiler 不在此列, 因为他自己就是典型用户

## Chap 3. What You Can't Say

## Chap 5. The other Road Ahead.

### 逆向"人月神话"

只要你还在很活跃的开发产品，就免不了要亲自做系统管理.

## Chap 6. How to Make Wealth?

创业不是魔术, 无法改变创造财富的法则. 如果你想赚 100w, 就必须忍受对应的压力.

* 创业公司的真正意义, 自发形成. (成败取决于前五个人)
* 如果你发现一种新的做事方式, 它的经济价值取决于有多少人使用这种新的方式.
* 实际操作中, 故意选择那些`困难`的技术问题.(对你困难, 对大公司更困难)(\*)
  * 之后各种选择都选择`困难`

## Chap 12. Beating the Averages

* 画家, 画笔. (Eric-Raymond: `How to Become a Hacker?`)
* 选择功能强大, 且效率可接受的语言, 否则都是不正确的选择.
* 没有 macro, 如何编程呢?
  * 一般 source 经过 compiler 解析生成解析数, Lisp 的奇特之处, 就是完全可以写程序, 控制这些解析树.进行任意的存储操作.

## Chap 13.

* 麦卡锡, 并不是想创造语言, 只是希望简洁的方法定义图灵机.
  * 不应该把 Lisp 与 1958 年的硬件相比, QuickSort 最快, 也是 1960 年提出的.
* Lisp 和 Fortan 代表了编程语言的两大方向:
  * 前者的基础是数学, 后者是硬件架构
* 9)
  * 读取期运行代码, 使得用户可以 reprogram Lisp 语法
  * 编译期运行代码, 是 Lisp Macro 运行的基础
  * 运行期编译代码, Lisp 在 Emacs 中充当扩展语言.
  * 运行期读取代码, 使得程序间可以使用 S-表达式通信,
* Lisp 程序, 直接以解析树的方式展现出来.
* Lisp 的最大优势, 在于开发那些解决`困难问题`的`复杂程序`

## Chap. 14

* 专家级黑客一眼就能分辨出语言的好坏
* 编程是一个及物动词, 必要要有依赖的系统. (eg: C 依赖 Unix)
* 简洁
  * 内核简洁, 但又混乱(允许 hacker 任意改造)
* 一次性程序
  * perl 是个典型例子
* 函数库
  * perl 拥有强大操作字符串的函数库
* 效率
  * 运行速度只取决于一些关键瓶颈

## Chap 15.

* 怎么理解编程语言? : 促进程序从无到有的工具.
