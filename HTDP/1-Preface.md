### Preface

This book focuses on habits of **good programming**.

By “good programming,” we mean an approach to the creation of software that relies on **systematic** thought, and so on.

The rest of this preface explains in detail what we mean with “systematic design,”.

### Systematic Program Design
- design recipes
- iterative refinement.

#### design recipes
Design Recipes apply to both complete programs and individual functions. 

1. complete programs: GUI and batch (programs).
2. function-level: Figure 1 displays its six essential steps.

#### iterative refinement
Iterative Refinement addresses the issue that problems are complex and multifaceted.

>Getting everything right at once is nearly impossible.
>
>Instead, computer scientists borrow iterative refinement from the physical sciences to tackle this design problem.
>
>In essence, iterative refinement recommends stripping away all inessential details at first and finding a solution for the remaining core problem.

This book introduces iterative refinement in two different ways:
1. when the design of programs becomes complex, 4th part.
2. state increasingly complex variants of the same problem, first three parts.

### DrRacket and the Teaching Languages
Learning to design programs calls for repeated hands-on practice.
Learning to design programs is primarily about `the study of principles and the acquisition of transferable skills`.
> We firmly believe that using such a series of teaching languages provides readers with a superior preparation for creating programs for the wide spectrum of professional programming languages (JavaScript, Python, Ruby, Java, and others).

An interactive program development environment such as DrRacket simplifies the learning process in two ways.
1. it enables novice programmers to manipulate data directly.
2. Second, the arrangement strictly separates data and data manipulation (from input and output of information from the “real world.”)

### Skills that Transfer
1. analytical skills as mathematics, especially (pre)algebra and geometry. 
> But, unlike mathematics, working with programs is an active approach to learning. Creating software provides immediate feedback and thus leads to exploration, experimentation, and self-evaluation.
2. analytical reading and writing skills.
> Without solid reading and comprehension skills, it is impossible to design programs that solve a reasonably complex problem.

### This Book and Its Parts
### The Differences
### Acknowledgments from the First Edition
### Acknowledgments
